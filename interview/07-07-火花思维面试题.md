---
title: 火花思维面试题
date: 2021-07-07 19:34:47
tags:
categories:
updated:
description:
keywords:
---
前端开发的理解：
首先，能高效流畅的展示用户页面；其次需要同后端数据进行交互，

#### 火花思维

1, rem的原理 / flex / px 的区别
	

2, 浏览器敲入回车到渲染的原理
	a, 域名解析： DNS协议根据对应的域名解析找到对应的ip地址
	b, TCP的三次握手
	c, 浏览器拿到响应文件后开始解析，浏览器的解析

3, vue源码

4, promise的原理
	构造函数调用 + 回调的执行 + settimeout实现异步
	浏览器的事件循环
	
5, react 的原理

6, 排版分帧渲染原理
	将任务最小化，避免过长时间的占用主线程， 

	requestionAnimation

7, 电子书性能优化原理
	1， 虚拟滚动（渲染可视区域的元素， 通过监听浏览器的滚动事件）

8, async/ await和 promise的区别
	async/ await 是 promise + genarator 的产物

	1 promise是ES6，async/await是ES7
	2 async/await相对于promise来讲，写法更加优雅
	3 reject状态：
    	1）promise错误可以通过catch来捕捉，建议尾部捕获错误，
    	2）async/await既可以用.then又可以用try-catch捕捉


9, 我的技术栈是什么

10, axiou内部的封装
	  

#### 航旅纵横：

1，js加载的 defer 和 async的 区别
	defer: dom tree + css rule tree 渲染完成之后
	aysnc: 是异步加载，加载完成就会执行

2，css的flex布局

3， vuex是如何注入到vue中的

4， webpack的配置

5， 浏览器渲染原理
		dom tree + css rule tree = render tree


#### 水滴筹

1， 0.1 + 0.2 为啥不为0.3

2， 怎样从数值中找到小数点最多的小树

3， axiou的二次封装

4， 多次请求如何避免

5， 开发自定义的plugin

6， plugin 和 组件的区别

7, 短期的职业规划

8, 对团队的氛围的要求

#### moke(发展方向)

#### 阿里国际部

1, promise的原理

2, 对于book系统如何做性能优化

#### 全优车(一面通过)

display: flex

初始值 （对象, a,d, ） -> dispatch (去修改) -> use(state)

#### 国美

1， vue.component 和 vue.extend 的区别

2, webpack 配置

3, css的loader写一些函数
	
4, 移动端布局除了rem还有什么

		1, rem
		2, postcss-pxtorem
		3, postcss-px-to-viewport: vh + vw
		4, flex + rem

5, 强缓存和协商缓存的区别， http的304代表什么意思

	1,304代表缓存有效
  2, 区别是：
		a, 强缓存在请求时不会向服务器端发送真实的请求任务， 因为在经历浏览器缓存的时候就命中了， 返回的状态码是200
		b, 协商缓存会向服务器发送真是的请求，而是否使用缓存则根据浏览器去判断， 如果命中缓存返回的状态码是304
	3, 强缓存：
			a, Cache-Control
			b, Expires
	4, 协商缓存
			a, Last-Modified和If-Modified-Since
			b, ETag和If-None-Match

6, vue编译原理

7, js的继承有那些

		a. 原型链继承
		b. 构造函数式继承
		c. 组合继承
		c. 原型式继承
		d. 寄生式继承
		e. 寄生组合式

8, 开发自定义的vue的plugin


#### 开课吧

1. 跨域的处理

	前端跨域处理:
	a. jsonp
	b. websocket: 允许跨域通信
	c. 服务端设置为 Access-Control-Allow-Origin: *
	d. 

2. 浏览器渲染原理

3. es6和es7新增的那些特性

4. 数组的方法

5. 箭头函数和普通函数的区别

6. 数字转化成 [w, 千万， 百万]

7. react hook

8. rem的转换

9. js闭包

10. 数组排序，求最大值最小值和平均值

11. 首屏加载优化


#### 有赞

1. 手写reduce

``` javascript

// 实现一个 Array.prototype.reduce
// [1,2,3].reduce((a,b)=>a+b);

Array.prototype.cutomReduce = function (fn, initVal) {
    const list = this
    let result =  initVal
    const index = list.length -1
    let cur = 0
    while(cur <= index) {
        const data = fn(result, list[cur], index)
        result = data
        cur++
    }
    return result
}

console.log([1,2,3].cutomReduce((pre, item) => pre + item, 1))

```

2. 实现一个 Promise.all.then(res: [] => {}) 
```javascript

	console.log('----------------------------------第二题----------------------------------')
// 实现一个 Promise.all.then(res: [] => {})

Promise.customAll = (list) => {
    new Promise((resolve, reject) => {
        const index = list.length -1
        const result = []
        const res = (i, value) => {
            try{
                const isObject = typeof value === 'object' || typeof value === 'function'
                const then = value.then
                if (isObject && then) {
                    then((val) => {
                        res(i, val)
                    }, reject)
                }
                result[i] = value
                if (index=== 0) {
                    resolve(resolve)
                }
            } catch(err) {
                reject(err)
            }
        }

        for (let i = 0 ; i <= index; i++) {
            res(i, list[i])
        }

    })
}
```


3, 浏览器缓存

4, vue的path算法

5. webwork

6. 性能优化



### 一点资讯

1. vue的path算法
2. 防抖、节流
3. websockt
4. 对闭包的理解
		有权访问另一个函数作用域中的变量的函数

5. vue的双向数据绑定原理
6. 直播断流的处理
7. 性能优化（虚拟滚动， webwork)
8. js的继承有哪些

		1. 原型链继承: 父类实例作为自雷的原型
		2. 构造函数继承: 就父类构造函数内容复制给子类的构造函数
		3. 组合继承
   
		4. 原型式继承
		5. 寄生式继承
		6. 寄生组合式继承
9.  箭头函数和普通函数的区别

	区别：
	1. 箭头函数没有自己的this指向， 它只会从自己作用域链上一层继承this
	2. 箭头函数不能作为构造函数
	3. 箭头函数没有自己的arguments对象
	4. 箭头函数没有prototype


#### 闪电快车

1. vue的path算法
2. vuex的getter
3. vue的源码
4. 浏览器的事件循环
5. vue虚拟dom的作用
  