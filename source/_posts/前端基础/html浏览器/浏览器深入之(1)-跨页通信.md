---
title: 浏览器深入之跨页通信
date: 2021-08-23 22:37:10
updated: 2021-08-23 22:37:10
tags: [前端基础, 浏览器]
categories: [浏览器]
description:
keywords: 浏览器上各tab页之间的通信
---
#### 同源: 域名，协议，端口相同

#### 跨域: 指跨域名的访问

##### 广播模式
##### 同源页之间的通信

1. BroadcastChannel

```javascript
// 连接到广播频道
var bc = new BroadcastChannel('test_channel');
// 发送简单消息的示例
bc.postMessage('This is a test message.');
// 简单示例，用于将事件打印到控制台
bc.onmessage = function (ev) { console.log(ev); }
```

2. Service Worker: 长期运行在后台的worker， 能够实现与页面的双向通信

```javaScript

// 注册serviceWorker
navigator.serviceWorker.register('serviceWorker的文件地址').then(function () {
	console.log('service worker 注册成功')
})

// serviceWorker 中的逻辑
self.addEventListener('message', function ( e) {
	console.log('serviceWorker receive  message', e.data)

	e.waitUntil(
		self.clients.matchAll().then(function(clients) { // 获取当前注册了该 Service Worker 的所有页面
			if (!clients || clients.length === 0) {
				return;
			}
			clients.forEach(function (client) {
				client.postMessage(e.data)
			})
		})
	)
})

// 页面逻辑
navigator.serviceWorker.addEventListener('message', function (e) {
	const data = e.data 
	const text = `receive ${data.msg}`
	console.log(text)
})

// 同步数据
navigator.serviceWorker.controller.postMessage(newData)
```

3. LocalStorage： 在同一个域下的不同页面之间触发； 在A页面注册了 storage 的监听处理，只有在跟 A 同域名下的 B 页面操作 storage 对象， A 页面 才会触发事件

```javaScript
	interface  EType {
		key: DOMString; // 被修改的建值
		newValue: DOMString; // 被修改的新的值
		oldValue: DOMString; // 修改前的值
		storageArea: nsIDOMStorage // 被操作的storage对象
		url: DOMString // key 发生改变的对象所在的文档地址
	}

	window.addEventListener('storage', (e) => {
			if (e.key === 'ctc-msg') {
        const data = JSON.parse(e.newValue);
        const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
        console.log('[Storage I] receive message:', text);
    }
	})

```


#### 共享存储模式： 
4. sharedWorker: 普通的 worker 之间是独立运行的、数据互不相通，而多个 Tab 注册的 shareWorker则可以实现
数据共享


post： sharedWorker 收到消息后将数据存储下来
get: sharedWorker 收到该消息后将保存下来的数据通过 postMessage 传给注册它的页面，让页面主动通过 get 来获取数据

```javaScript

// 实例化一个shareWorker 实例， 构造函数 第二个参数是sharedWorker 的名字也可以为空
const sharedWorker  = new SharedWorker('./util.shared.js', 'ctc')

// 监听 get 消息的返回数据
sharedWorker.port.addEventListener('message', function (e) {
	const data = e.data;
  const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
  console.log('[Shared Worker] receive message:', text);
})

// 定时轮询，发送 get 指令的消息
setInterval(function () {
    sharedWorker.port.postMessage({get: true});
}, 1000);

// sharedWorker 逻辑

let data = null
self.addEventListener('connect', function (e) {
	const port = e.ports[0]
	port.addEventListener('message', function (e){

		if (event.data.get) {
			data && port.postMessage(data)
		} else {
			data = event.data
		}
	})
})

```

5. indexedDB 

``` javascript

// 打开数据库
function openStore() {
	const storeName = 'ctc-aleinzhou'
	return new Promise(function (resolve, reject) {

		if (!('indexedDB' in window)) {
			return reject(`不支持indexedDB`)
		}
		
		const request = indexedDB.open('CTC_DB', 1)
		request.onerror = reject
		request.onsuccess = e => resolve(e.target.result)
		request.onupgradeneeded = function (e) {
			const db = e.srcElement.result
			if (e.oldVersion === 0 && !db.objectStoreNames.contains(storeName)) {
				const store = db.createObjectStore(storeName, { keyPath: 'tag'})
				store.createIndex(storeName + 'index', 'tag', {unique: false})
			}
		}
	})
}

// 存储数据
function saveData(db, data) {
	return new Promise(function(resolve, reject) {
		const STORE_NAME = 'ctc-aleinzhou'
		const tx = db.transaction(STORE_NAME, 'readwrite')
		const store = tx.objectStore(STORE_NAME)
		const request = store.put({tag: 'ctc_data', data});
    request.onsuccess = () => resolve(db);
    request.onerror = reject;
	})
}

// 查询数据
function query(db) {
	const STORE_NAME = 'ctc_aleinzhou';
	return new Promise(function (resolve, reject) {
			try {
					const tx = db.transaction(STORE_NAME, 'readonly');
					const store = tx.objectStore(STORE_NAME);
					const dbRequest = store.get('ctc_data');
					dbRequest.onsuccess = e => resolve(e.target.result);
					dbRequest.onerror = reject;
			}
			catch (err) {
					reject(err);
			}
	});
}

// 页面消息读取
openStore().then(db => saveData(db, null)).then(function (db) {
	// 轮洵查询
	setInterval(function () {
			query(db).then(function (res) {
					if (!res || !res.data) {
							return;
					}
					const data = res.data;
					const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
					console.log('[Storage I] receive message:', text);
			});
	}, 1000);
});

```

##### 口口相传模式

6. window.open + window.opener
使用 window.open 打开页面时该方法会返回一个被打开页面window的引用， 通过window.opener可以获取到打开它页面的引用

```javaScript
	let childWins = []
	document.getElementById('btn').addEventListener('click', function() {
		const win = window,.open('./some/sample')
		childWins.push(win)
	})

	// 发送消息
	childWins = childWins.filter(w => !w.closed)
	if (childWins.length <= 0) return

	// 页面内打开的窗口传递数据
	childWins.forEach(w => w.postMessage(data))
	// 本页面传递数据
	if (window.opener && !window.opener.closed) {
		window.opener.postMessage(data)
	}

	// 接收消息
	window.addEventListener('message', function(e) {
		const data = e.data
		const text = `[receive] data mas __tab ${data.form}`
		console.log(text)

		if (window.opener && !window.opener.closed && data.formOpener) {
			window.opener.postMessage(data)
		}

		childWins = childWins.filter(w => !w.closed)
		if (childWins && !data.fromOpener) {
			childWins.forEach(w => w.postMessage(data));
		}
	})
```

原理： 让每个页面都肩负传递消息的责任
缺点： 不是通过 window.open 打开页面，直接在浏览器中地址输入，这个联系就被打破了

##### 基于服务端方式
7. webSocket
#### 非同源页面通信
iframe 桥： iframe可以指定 origin来忽略同源限制，因此在页面中嵌入一个iframe，就可以使用同源页面的通信方式